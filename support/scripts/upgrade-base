#!/usr/bin/env node

// *************************************************************************
//  Copyright 2018 LGS Innovations
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// ************************************************************************/

//  This script upgrades the base. This  script lives in a specific place.
//  Leave it there.  ./bits/Linux/bits-files/bits-base/scripts
//
//  -h,--help       display this help and exit.
//  -t,--target     the target base file to upgrade to
//  -P              bits base directory
//
//  exit code 1: incorrect arguments supplied, files incorrect, or key not private
//  exit code 2: upgrade failed
//  exit code 4: upgrade suceeded with partial failures error log should be presented to user
//  exit code 8: upgrade succeded with yarn errors, error log should be presented to user

'use strict';

const fs = require('fs');
const path = require('path');
const spawnSync = require('child_process').spawnSync;

// Static items
const d = new Date();
const ENV_DATE = '' + d.getFullYear()
    + ('0' + (d.getMonth()+1)).slice(-2)
    + ('0' + d.getDate()).slice(-2)
    + '-'
    + ('0' + d.getHours()).slice(-2)
    + ('0' + d.getMinutes()).slice(-2)
    + ('0' + d.getSeconds()).slice(-2);

const LOG_FILE_NAME = `/tmp/bits-upgrade-log-${ENV_DATE}`;

const FOLDER_CREATION_MODE = 0o700;

const args = parseArgs(process.argv, {
  default: {
    rootBaseDir: '/opt/bits/',
    rootDataDir: '/var/bits',
    target: '',
    help: false,
    logLevel: 'info', // error=0, warn=1, info=2, verbose=3, debug=4, silly=5
    noserver: false,
  },
  alias: {
    rootBaseDir: ['P', '-base'],
    rootDataDir: ['d', '-data'],
    target: ['t', '-target'],
    help: ['h', '-help'],
    logLevel: ['l', '-level'],
    noserver: ['n', '-noserver'],
  },
});

console.log('args:\n', args);
if (args.help) {
  printUsage();
}

console.log(`* Upgrade Base: logging to ${LOG_FILE_NAME}`);
log(`* ARGS: [${process.argv}]`);
const scriptName = path.parse(process.argv[1]).base;
log(`* Script: ${scriptName}`);

const user = whoami();
log(`* Current user: ${user}`);

const tmpdir = fs.mkdtempSync('/tmp/bitsupdater.');

log(`* Working directory: ${tmpdir}`);
fs.chmodSync(tmpdir, 0o766);

let argumentError = false;

// validate user
if (user !== 'root') {
  log(`* ${scriptName}: ERROR: This script must be run as root`);
  argumentError = true;
}

// validate base directory (-P)
if (!args.rootBaseDir) {
  log('* ERROR: no base dir specified (-P <dirname>)');
  argumentError = true;
} else {
  // if the argument was supplied, make sure the directory exists
  try {
    mkdirp(args.rootBaseDir, FOLDER_CREATION_MODE);
    log(`* Base Dir: ${args.rootBaseDir}`);
  }
  catch (err) {
    if (err.code === 'ENOTDIR') {
      log(`* ERROR: Specified base directory '${args.rootBaseDir}' is not a directory`);
    } else {
      log(`* ERROR: Unknown error ensuring base directory '${args.rootBaseDir}' exists:`, err);
    }
    argumentError = true;
  }
}

// validate data directory (-d)
if (!args.rootDataDir) {
  log('* ERROR: no data dir specified (-d <dirname>)');
  argumentError = true;
} else {
  // if the argument was supplied, make sure the directory exists
  try {
    mkdirp(args.rootDataDir, FOLDER_CREATION_MODE);
    log(`* Data Dir: ${args.rootDataDir}`);
  }
  catch (err) {
    if (err.code === 'ENOTDIR') {
      log(`* ERROR: Specified data directory '${args.rootDataDir}' is not a directory`);
    } else {
      log(`* ERROR: Unknown error ensuring data directory '${args.rootDataDir}' exists:`, err);
    }
    argumentError = true;
  }
}

// validate target filename
if (!args.target) {
  log('* ERROR: need to supply new base ROMG (-t <filename>)');
  argumentError = true;
} else if (fs.existsSync(args.target) && fs.statSync(args.target).isFile()) {
  log(`* Target: ${args.target}`);
} else {
  log(`* ERROR: Specified target is not a file (${args.target})`);
  argumentError = true;
}

// validate log level
const validLevels = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'];
if (!validLevels.includes(args.logLevel)) {
  log(`* ERROR: invalid log level provided (${args.logLevel})`);
  argumentError = true;
} else {
  log(`* Log level is (${args.logLevel})`);
}

if (argumentError) {
  printUsage();
}

// Unpack the components we need into our TMPDIR
const untarResults = spawnSync('tar',
  ['xf', args.target, '--strip-components=3', '-C', tmpdir, './support/scripts'],
  {});
if (untarResults.output.join('').length > 0) {
  log('* Untar Results:\n' + untarResults.output.join('\n').trim());
}

// Now launch the upgrade app
log(`* Launching upgrade-app in ${tmpdir}`);
const execArgs = ['./upgrade-app.js',
  '-t', path.resolve(args.target),
  '-P', args.rootBaseDir,
  '-d', args.rootDataDir,
  '-o', LOG_FILE_NAME,
  '-l', args.logLevel
];
if (args.noserver) {
  execArgs.push('--noserver');
}
const {error, output, status} = spawnSync('node',
  execArgs,
  {cwd: path.join(tmpdir, 'upgrade-server')});
if (error) {
  log('* Upgrade App Error Results:\n' + error);
}
if (output) {
  log('* Upgrade App Output:\n' + output);
}

log(`* Back from Upgrade App (${status})`);

if (status > 0) {
  log('* Cleaning up working files');
  let {output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', 'node_modules')], {});
  log('* rm (' + path.join(tmpdir, 'upgrade-server', 'node_modules') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', 'public')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', 'public') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', '*.js')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', '*.js') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', '*.json')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', '*.json') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', '*.lock')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', '*.lock') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', '*.txt')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', '*.txt') + ') results: ' + output.join('\n').trim());
  ({output} = spawnSync('rm', ['-rf', path.join(tmpdir, 'upgrade-server', '*.MD')], {}));
  log('* rm (' + path.join(tmpdir, 'upgrade-server', '*.MD') + ') results: ' + output.join('\n').trim());
  finish(status);
} else {
  // completely remove TMPDIR, but only on success
  log('* Clean exit');
  const results = spawnSync('rm',
    ['-rf', tmpdir],
    {});
  if (results.output.join('').length > 0) {
    log('* rm Results: ' + results.output.join('\n').trim());
  }
  finish(0);
}

// Cleanup on exit
function finish(exitCode) {
  log('* INFO Finishing Script');
  if (fs.statSync(LOG_FILE_NAME).isFile()) {
    const upgradeDir = path.join(args.rootDataDir, 'upgrade');
    const baseLogName = path.basename(LOG_FILE_NAME);
    log(`* INFO Moving Upgrade Log to data directory as ${baseLogName})`);
    try {
      mkdirp(upgradeDir, FOLDER_CREATION_MODE);
      spawnSync('mv', ['-v', LOG_FILE_NAME, upgradeDir], {});
      const latestLinkName = path.join(upgradeDir, 'latest');
      if (fs.statSync(latestLinkName).isFile()) {
        fs.unlinkSync(latestLinkName);
      }
      fs.symlinkSync(path.join(upgradeDir, baseLogName), latestLinkName);
    } catch (err) {
      if (err.code === 'ENOTDIR') {
        log(`* ERROR: Unable to save log file; '${upgradeDir}' exists but is not a directory`);
      } else {
        log(`* ERROR: Unknown error creating log file copy in '${upgradeDir}':`, err);
      }
    }
  }
  process.exit(exitCode);
}

function log(...args) {
  const d = new Date();
  const logTime = ('0' + d.getHours()).slice(-2)
    + ':'
    + ('0' + d.getMinutes()).slice(-2)
    + ':'
    + ('0' + d.getSeconds()).slice(-2)
    + '.'
    + ('00' + d.getMilliseconds()).slice(-3);
  fs.appendFileSync(LOG_FILE_NAME, logTime + ' ' + args.join('\n') + '\n');
}

function mkdirp(dirpath, mode) {
  try {
    ensureDirectoryExists(dirpath, mode)
  } catch(err) {
    if ('ENOENT' === err.code) {
      mkdirp(path.dirname(dirpath, mode));
      fs.mkdirSync(dirpath, mode);
    } else {
      throw(err);
    }
  };
}

function ensureDirectoryExists(dirpath, mode) {
  try {
    fs.mkdirSync(dirpath, mode);
  }
  catch(err) {
    if (err.code !== 'EEXIST') {
      throw(err);
    }
  };
  if (!fs.statSync(dirpath).isDirectory()) {
    throw Object.assign(new Error('Dirpath is not directory'), {code: 'ENOTDIR'});
  }
}

function parseArgs(argArray, options) {
  const results = {};
  // initialize results with default values, if any
  if ('default' in options) {
    for (let key in options.default) {
      if (options.default.hasOwnProperty(key)) {
        results[key] = options.default[key];
      }
    }
  }
  // extract values from argArray based on alias args
  if ('alias' in options) {
    // the number of arguments in our argArray doesn't change, so
    // cache this value
    const argLen = argArray.length;
    // walk through each argument on the command line.  If it
    // starts with '-', check it against our aliases
    for (let i = 0; i < argLen; i++) {
      const argument = argArray[i];
      if (argument.charAt(0) === '-') {
        // argument starts with '-'; find a matching alias
        for (let key in options.alias) {
          if (options.alias.hasOwnProperty(key)) {
            const aliasKeys = options.alias[key];
            aliasKeys.forEach((aliasKey) => {
              if (argument === ('-' + aliasKey)) {
                // we found a matching alias key... now set the
                // result accordingly
                let parameter = null;
                if (i < argLen - 1) {
                  parameter = argArray[i+1];
                }
                if (key in results) {
                  // handle booleans
                  if (typeof(results[key]) === 'boolean') {
                    results[key] = true;
                  } else {
                    results[key] = parameter;
                  }
                } else {
                  // key does not yet exist... assume it's a string
                  results[key] = parameter;
                }
              }
            });
          }
        }
      }
    }
  }
  return results;
}

function printUsage() {
  console.log(`
BITS Upgrade Script - usage:
  node upgrade-base -P BASE -d DATA -t TARGET [-h] [-l LEVEL] [-ns]
where:
  -h: show this usage text
  -t TARGET: use TARGET as the target ROMG file
  -P BASE: use BASE as the BITS base directory
  -d DATA: use DATA as the BITS data directory
  -l LEVEL: set log level to LEVEL, where LEVEL is one of:
     error, warn, info, verbose, debug, silly (default is info)
  -n: Do not start the BITS Upgrade web server
CAVEAT: this script must be run as root user`);
  process.exit(1);
}

function whoami() {
  const results = spawnSync('whoami', [], {});
  return results.output.join('\n').trim();
}
